!!! segfault si lancee avec env_vars vide !!!
code exit ctrl-C = 1
code exit parsing syntaxe = 258
code exit inexisting in/outfile or bad permission for in/outfile = 1
permission denied command = 126;
command not found = 127;

!!! exit_code doit rester un int dans la structure ENV (sinon ca peut pas etre egal a 258) -> c'est dans exit qu'il faut mettre en
Usigned char pour gerer l'overflow ( si exit 255 -> exit_code = 255, si exit 256 -> exit_code = 0)

gerer infile outfile apres fork

export -aaa
--> en fait, ne fait rien. Si autre char apres le a, dira :
export : -[autrechar]: invalid option.
Skip donc les a, pareil avec f et quelques autres char.
---> je propose qu'on s'en branle :-) (surtout que ce sont des options)
---> Chez nous : export: '-aaa': not a valid identifier. (je pense que c'est tres bien.)

export coucou= rien dans env --> FAUX

faut-il virer la ligne OLDPWD de l'env et la remplacer par un OLDPWD vide UNIQUEMENT dans export ? (si nouveau terminal)
->super chiant pour pas grand chose...

variable SHLVL important ou pas dans gestion signale ? (si on lance un minishell dans un minishell, d'ailleurs, "command not found", donc essayer de lancer le programme depuis le path actuel avant de chercher dans $PATH?

!!! child pas dans process fille si commande seule et que builtin !!
childs :
-Path absolu
-builtin
-construction path sinon error
-execve

waitpid dans une boucle a la fin de tous les fork et pas dans le boucle de fork en elle meme

CE QUI EST OK ET AUX NORMES :
- pwd.c
- unset.c
- exit.c
- env.c
- echo.c
- pipe_parse.c
- expander.c
- free.c
- commands.c
- del_quotes.c

> """" ->aucune idee de ce que le notre va faire

Bien check tous les mallocs (strjoin, strrim) etc

Redirection pipe fonctionnera seule, mais time out si il y a une redirection de fichier avant dans notre program, et bash ne time out pas...
-> idee : remettre pipefd dans le tableau exchange dans la struct, si jamais un outfile est modifie, on ecrit \0 dedans et on le ferme. Ensuite, lors de la redirection, on redirige sur les exchange, puis sur in/outfile si besoin.

Si une chaine d'expander errone apres une redirection de fichier (ex: ls > $lfgkjfgljglgh) -> erreur et on revient au debut de la loop minishell -> non c bz ca doit etre gere dans le process enfant :((

Gestion de signaux a revoir si minishell dans minishell (ou on s'en fout? -> pour moi non, mais comment faire? strcmp reverse avec minishell et creer un cinquieme handler?)

=>leak dans split_space (commands.c); super bizarre, ne leak pas quand il y a un expander, + d'autres cas mais jsplus lol
=>leaks readline qu'on peut free une fois add history et qu'on en a plus besoin(la segfault dans l'historique etait quand on avait free avant de add history)
=>dans free_cmds, avant de fermer in/outfile, verifier qu'ils ne soit pas a 0, sinon ca close STDIN => minishell s'arrete


============================EVAL========================
Leaks when using exit
Wrong exit code
echo' $USER' doesn't understand the command
Segfault when entering minishell inside a minishell after unsetting SHLVL
unset $PATH goes out of minishell
