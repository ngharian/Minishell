GARDER CONTROLE SUR EXECVE
3 trigger POUR PIPES -> LA 1ERE, TOUTES LES INTERMEDIAIRES ET LA DERNIERE
ctrl C ou D dans delimiter
Variable globale -> signaux ?
PROMPT = REPERTOIRE COURANT ?

!!! gerer si guillemets fermes mais vides

symboles chiants entre pipes :

 | < > >> <<   c'est gere ca maintenant !
 
export n'export rien s'il y a une pipe

exit coucou 123 -> va exit + message erreur aussi
exit 123 coucou -> va pas exit

<< ne prend pas les variables d'environnement -> <<"$del" attendra $del ----> chez nous, attend "$del"

 c'est le dernier infile qui a prio sur les autres :
 cat <Makefile << del
 ou cat <<del <Makefile

si infile forcé, la commande arrive en 2e : <Makefile wc --->Comment le mettre dans la struct sans se faire chier ?

code exit ctrl-C = 1 
code exit parsing syntaxe = 258
!!! exit_code doit rester un int dans la structure ENV (sinon ca peut pas etre egal a 258) -> c'est dans exit qu'il faut mettre en
Usigned char pour gerer l'overflow ( si exit 255 -> exit_code = 255, si exit 256 -> exit_code = 0)

test megasplit =    hello "comment | ca va" oui | aurait on "|fini?" << file | telle 'est la qu|estion' <file
--------

<> on s'en branle, c'est un operateur en plus dont on ne doit pas s'occuper


fct arrow_parse
ext_parsing dans le fonction get_line
gerer infile outfile apres fork

pid_t waitpid(pid_t pid, int *stat_loc, int options);
option : WNOHANG -> va pas attendre le process child et renvoie 0 tant que le process n'est pas fini

Apres le megasplit, si <(<) ou >(>), on sait que la chaine de car suivante est soit infile, soit outfile -> ont met a jour nos structs
et on supprime les chaines de car dans le split
MAIS gerer variables environnement AVANT 

!!!! si erreur de parsing ne faisant pas exit -> mettre a jour historique sinon segfault!!!!

Creer outfiles doit etre fait AVANT virer les quotes mais apres l'expander et la redirection de pipe:
> ">coucou" -> creera fichier >coucou
> >coucou  ->syntax error
> si ca fail, reprendre le nom de infile pour pouvoir ecrire l'erreur une fois dans le process fille

Quand une commande a un outfile, rien n'est envoye dans la pipe ! :
ls > test | grep builtin >test2 -----> Rien dans test2 ;
ls | grep builtin >test2		-----> builtin dans test2

si infile pas accessible -> cmd s'execute pas - PAR COMMANDE :
< dsiohg ls | ls >test

TOUT debut de programme -> on utilise notre propre export pour update une variable '?' pour nos codes d'erreur
-> mettre un flag en debut pour nous autoriser a export ?, puis le changer pour plus qu'on puisse le faire apres

Question des whitespace dans les commandes : Faut-il vraiment gerer les tab et que sais-je ?
->pour l'instant, il n'y a que les fct check_pipes qui les prennent en compte

!!! $? seul fonctionne dans bash -> donne le code d'erreur + "command not found" - >normal car $? est remplace par sa valeur, et onc il prend la valeur comme le nom d'une commande 
(ex: "abcd" renvoie zsh: command not found: abcd. donc si $? = 3 et que commande "$?" -> la commande est transorfmee en "3" -> renvoie zsh: command not found: 3)

!!! if export te"st=cou"cou --->ca vire les guillemets !

$$ = donne une valeur qui semble random ???
-> NON : donne le PID

PROBLEME : export prend en compte les quotes....
-> export test="''"coucou"'"
-> Faire le export en premier, avant tout, a part ?

OMG export c'est env dans l'ordre alphabetique...
Pas tout a fait idem que dans bash car:
--->Parce que ./minishell dans zsh
--->derniere ligne dans env est pas la meme ./minishell ou usr/bin/env dans bash

!!HEADER

!! cd - ->>>normalement faut pas s'en occuper
creer dossier/changer terminal/supprimer dossier, quid ?
export a+=b
export -aaa

export coucou= rien dans env --> FAUX

export test=""""""coucou"""""" fera """coucou""" dans le notre 
et "coucou" dans bash, mais il peut aller se faire foutre.

faut-il virer la ligne OLDPWD de l'env et la remplacer par un OLDPWD vide UNIQUEMENT dans export ? (si nouveau terminal)
->super chiant pour pas grand chose...

!! /bin/ls devrait fonctionner...

variable SHLVL important ou pas dans gestion signale ? (si on lance un minishell dans un minishell, d'ailleurs, "command not found", donc essayer de lancer le programme depuis le path actuel avant de chercher dans $PATH?

1!!! child pas dans process fille si commande seule !!
childs :
-Path absolu
-builtin
-construction path sinon error
-execve

!!!! pour redirection de fichier et here doc, si par exemple <<     """""FIN"""" -> guillemwts supprimes et la chaine end of file est bien [FIN], meme chose pour in/out !!!
pour les problemes de open() pour les redirections, set in/out -1 et errno_file = errno, puis faire strerr(errno_file); dans le process pour afficher le bon message d'erreur.

waitpid dans une boucle a la fin de tous les fork et pas dans le boucle de fork en elle meme

CE QUI EST OK ET AUX NORMES :
- pwd.c
- unset.c
- exit.c
- env.c
- echo.c
- pipe_parse.c
- expander.c
- free.c
- commands.c
- del_quotes.c

> """" ->aucune idee de ce que le notre va faire

Bien check tous les mallocs (strjoin, strrim) etc

!!! export hello="''"coucou"" -> l'expander semble virer les ''

Redirection pipe fonctionnera seule, mais time out si il y a une redirection de fichier avant dans notre program, et bash ne time out pas...
-> idee : Si jamais outfile est modifie, check cmd->next != NULL et si c'est le cas et que cmd->next->infile != 0, le close et le remettre à 0;
--> pour ca il faut rechanger in et out, + le moment ou il est exec car sinon ca ne fonctionnera vraiment pas, ou changer le split_space de place, à voir :((